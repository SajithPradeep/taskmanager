-- Drop function if exists (with CASCADE to handle dependent triggers)
DROP FUNCTION IF EXISTS update_updated_at_column() CASCADE;
DROP FUNCTION IF EXISTS handle_new_user() CASCADE;

-- Drop existing tables in correct order (respecting foreign key constraints)
DROP TABLE IF EXISTS task_comments CASCADE;
DROP TABLE IF EXISTS task_history CASCADE;
DROP TABLE IF EXISTS tasks CASCADE;
DROP TABLE IF EXISTS profiles CASCADE;

-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = timezone('utc', NOW());
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create profiles table
CREATE TABLE profiles (
  id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  email TEXT UNIQUE NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW()),
  PRIMARY KEY (id)
);

-- Create tasks table
CREATE TABLE tasks (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  title TEXT NOT NULL,
  description TEXT,
  status TEXT NOT NULL DEFAULT 'not_started' CHECK (status IN ('not_started', 'in_progress', 'completed')),
  priority TEXT CHECK (priority IN ('high', 'medium', 'low')),
  size TEXT CHECK (size IN ('XS', 'S', 'M', 'L', 'XL', 'WEEK', 'MONTH', 'YEAR')),
  category TEXT CHECK (category IN ('personal', 'office', 'career', 'family')),
  expected_completion_date TIMESTAMP WITH TIME ZONE,
  started_at TIMESTAMP WITH TIME ZONE,
  completed_at TIMESTAMP WITH TIME ZONE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW())
);

-- Create task history table
CREATE TABLE task_history (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  task_id BIGINT REFERENCES tasks(id) ON DELETE CASCADE NOT NULL,
  action TEXT NOT NULL CHECK (action IN ('created', 'status_changed', 'field_updated', 'comment_added')),
  previous_status TEXT CHECK (previous_status IN ('not_started', 'in_progress', 'completed', NULL)),
  new_status TEXT CHECK (new_status IN ('not_started', 'in_progress', 'completed', NULL)),
  field_name TEXT,
  old_value TEXT,
  new_value TEXT,
  changed_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW()),
  changed_by UUID REFERENCES profiles(id) ON DELETE SET NULL
);

-- Create comments table
CREATE TABLE task_comments (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  task_id BIGINT REFERENCES tasks(id) ON DELETE CASCADE NOT NULL,
  user_id UUID REFERENCES profiles(id) ON DELETE CASCADE NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW()),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc', NOW())
);

-- Create triggers for updated_at
CREATE TRIGGER update_tasks_updated_at
  BEFORE UPDATE ON tasks
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON profiles
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_comments_updated_at
  BEFORE UPDATE ON task_comments
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Create function to handle new user registration
CREATE OR REPLACE FUNCTION handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email)
  VALUES (NEW.id, NEW.email);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Create trigger for automatic profile creation
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE FUNCTION handle_new_user();

-- Enable Row Level Security
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE tasks ENABLE ROW LEVEL SECURITY;
ALTER TABLE task_history ENABLE ROW LEVEL SECURITY;
ALTER TABLE task_comments ENABLE ROW LEVEL SECURITY;

-- Profiles policies
CREATE POLICY "Enable read access for own profile"
  ON profiles FOR SELECT
  USING (auth.uid() = id);

CREATE POLICY "Enable insert access for own profile"
  ON profiles FOR INSERT
  WITH CHECK (auth.uid() = id);

CREATE POLICY "Enable update access for own profile"
  ON profiles FOR UPDATE
  USING (auth.uid() = id);

-- Tasks policies
CREATE POLICY "Enable read access for own tasks"
  ON tasks FOR SELECT
  USING (auth.uid() = user_id);

CREATE POLICY "Enable insert access for own tasks"
  ON tasks FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Enable update access for own tasks"
  ON tasks FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Enable delete access for own tasks"
  ON tasks FOR DELETE
  USING (auth.uid() = user_id);

-- Task history policies
CREATE POLICY "Enable read access for own task history"
  ON task_history FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM tasks
    WHERE tasks.id = task_history.task_id
    AND tasks.user_id = auth.uid()
  ));

CREATE POLICY "Enable insert access for own task history"
  ON task_history FOR INSERT
  WITH CHECK (EXISTS (
    SELECT 1 FROM tasks
    WHERE tasks.id = task_history.task_id
    AND tasks.user_id = auth.uid()
  ));

-- Task comments policies
CREATE POLICY "Enable read access for task comments"
  ON task_comments FOR SELECT
  USING (EXISTS (
    SELECT 1 FROM tasks
    WHERE tasks.id = task_comments.task_id
    AND tasks.user_id = auth.uid()
  ));

CREATE POLICY "Enable insert access for task comments"
  ON task_comments FOR INSERT
  WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Enable update access for own comments"
  ON task_comments FOR UPDATE
  USING (auth.uid() = user_id);

CREATE POLICY "Enable delete access for own comments"
  ON task_comments FOR DELETE
  USING (auth.uid() = user_id); 